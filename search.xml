<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java创建对象的几种方式</title>
    <url>/2020/04/17/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Java创建对象的几种方式"><a href="#Java创建对象的几种方式" class="headerlink" title="Java创建对象的几种方式"></a>Java创建对象的几种方式</h1><h3 id="1-用new关键字常简对象"><a href="#1-用new关键字常简对象" class="headerlink" title="1.用new关键字常简对象"></a>1.用new关键字常简对象</h3><pre><code class="java">public class Main{
    public static void main(String[] args) {
        Main main = new Main();
        main.print();
    }

    public void print() {
        System.out.println(&quot;使用new关键字创建对象&quot;);
    }
}</code></pre>
<h3 id="2-使用反射机制创建对象"><a href="#2-使用反射机制创建对象" class="headerlink" title="2.使用反射机制创建对象"></a>2.使用反射机制创建对象</h3><p>用Class类或Constructor类的newInstance()方法。需要使用构造器。</p>
<blockquote>
<p>当使用Class类的newInstance()方法，调用的是无参构造方法。</p>
</blockquote>
<pre><code class="java">public class Main{
    public static void main(String[] args) throws IllegalAccessException, InstantiationException {
        Main main = Main.class.newInstance();
    }

    public void print() {
        System.out.println(&quot;使用new关键字创建对象&quot;);
    }
}</code></pre>
<blockquote>
<p>当使用java.lang.reflect.Constructor类里的newInstance方法，调用的是有参构造方法。</p>
</blockquote>
<pre><code class="java">public class Main{

    private int num;

    public Main(int num) {
        this.num = num;
    }

    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class p1 = Class.forName(&quot;Main&quot;);
        Constructor p2 = p1.getConstructor(String.class);
        Main main = (Main)p2.newInstance(1);
    }

    public void print() {
        System.out.println(&quot;使用new关键字创建对象&quot;);
    }
}</code></pre>
<h3 id="3、通过object类的clone方法"><a href="#3、通过object类的clone方法" class="headerlink" title="3、通过object类的clone方法"></a>3、通过object类的clone方法</h3><p>​    需要实现Cloneable接口，重写object类的clone方法。无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数</p>
<h3 id="4、使用反序列化"><a href="#4、使用反序列化" class="headerlink" title="4、使用反序列化"></a>4、使用反序列化</h3><p>​    通过ObjectInputStream的readObject()方法反序列化类当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。在反序列化时，JVM创建对象并不会调用任何构造函数。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝</title>
    <url>/2020/04/21/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="一、什么是浅拷贝和深拷贝"><a href="#一、什么是浅拷贝和深拷贝" class="headerlink" title="一、什么是浅拷贝和深拷贝"></a>一、什么是浅拷贝和深拷贝</h2><p>浅拷贝和深拷贝都是针对一个已有对象的操作。</p>
<p>在 Java 中，除了<strong>基本数据类型</strong>（元类型）之外，还存在 <strong>类的实例对象</strong> 这个引用数据类型。而一般使用 『 <strong>=</strong> 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。</p>
<p>而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。</p>
<blockquote>
<p>所谓的浅拷贝和深拷贝，只是在拷贝对象的时候，对 <strong>类的实例对象</strong> 这种引用数据类型的不同操作而已。</p>
</blockquote>
<p><strong>总结</strong></p>
<ul>
<li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ul>
<h2 id="二、Java-中的-clone"><a href="#二、Java-中的-clone" class="headerlink" title="二、Java 中的 clone()"></a>二、Java 中的 clone()</h2><h3 id="2-1-Object-上的-clone-方法"><a href="#2-1-Object-上的-clone-方法" class="headerlink" title="2.1 Object 上的 clone() 方法"></a>2.1 Object 上的 clone() 方法</h3><p>在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 <code>protected</code> ，所以我们可以在其子类中，使用它。</p>
<p>而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。</p>
<h3 id="2-2-浅拷贝示例"><a href="#2-2-浅拷贝示例" class="headerlink" title="2.2 浅拷贝示例"></a>2.2 浅拷贝示例</h3><pre><code class="Java">package vip.bwang;

class Address implements Cloneable {
    private String country;
    private String province;

    public Address(String country, String province) {
        this.country = country;
        this.province = province;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return (Address)super.clone();
    }
}

class Student implements Cloneable {
    private int age;
    private String name;
    private Address address;

    public Student(int age, String name, Address address) {
        this.age = age;
        this.name = name;
        this.address = address;
    }

    public Address getAddress() {
        return address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
//        Student cloned = (Student) super.clone();   //浅拷贝
//        cloned.address = (Address) address.clone(); //在浅拷贝得对象上，对所有引用类型也进行拷贝即是深拷贝
        return super.clone();
    }
}


public class CloneDemo {
    public static void main(String[] args) {
        try {
            Student stu1 = new Student(18, &quot;Sansa&quot;, new Address(&quot;China&quot;, &quot;Shanghai&quot;));
            Student stu2 = (Student) stu1.clone();
            System.out.println(stu1 + &quot;------&quot; + stu2);
            System.out.println(stu1.getAddress() + &quot;------&quot; + stu2.getAddress());
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p><img src="/" class="lazyload" data-src="/.com//E:%5Cblog%5Csource_posts%5C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%5Cimage-20200421210945081.png"  alt="image-20200421210945081"></p>
<p><strong>从结果可以看出，浅拷贝确实生成了两个不同的Student类对象，但是两个对象中引用类型address指向的是同一个Address类对象。</strong></p>
<h3 id="2-3-深拷贝示例"><a href="#2-3-深拷贝示例" class="headerlink" title="2.3 深拷贝示例"></a>2.3 深拷贝示例</h3><pre><code class="Java">package vip.bwang;

class Address implements Cloneable {
    private String country;
    private String province;

    public Address(String country, String province) {
        this.country = country;
        this.province = province;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return (Address)super.clone();
    }
}

class Student implements Cloneable {
    private int age;
    private String name;
    private Address address;

    public Student(int age, String name, Address address) {
        this.age = age;
        this.name = name;
        this.address = address;
    }

    public Address getAddress() {
        return address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Student cloned = (Student) super.clone();   //浅拷贝
        cloned.address = (Address) address.clone(); //在浅拷贝得对象上，对所有引用类型也进行拷贝即是深拷贝
        return cloned;
    }
}


public class CloneDemo {
    public static void main(String[] args) {
        try {
            Student stu1 = new Student(18, &quot;Sansa&quot;, new Address(&quot;China&quot;, &quot;Shanghai&quot;));
            Student stu2 = (Student) stu1.clone();
            System.out.println(stu1 + &quot;------&quot; + stu2);
            System.out.println(stu1.getAddress() + &quot;------&quot; + stu2.getAddress());
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p><img src="/" class="lazyload" data-src="/.com//E:%5Cblog%5Csource_posts%5C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%5Cimage-20200421211108856.png"  alt="image-20200421211108856"></p>
<p><strong>从输出结果可以看出，深拷贝是在浅拷贝的基础上，对对象中的引用数据类型也进行了对象拷贝。</strong></p>
<h2 id="三、一些思考"><a href="#三、一些思考" class="headerlink" title="三、一些思考"></a>三、一些思考</h2><p><strong>实现克隆需要实现Cloneable接口+调用java.lang.Object类中的clone方法呢？</strong></p>
<pre><code class="Java">package java.lang;

/**
 * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to
 * indicate to the {@link java.lang.Object#clone()} method that it
 * is legal for that method to make a
 * field-for-field copy of instances of that class.
 * &lt;p&gt;
 * Invoking Object&#39;s clone method on an instance that does not implement the
 * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception
 * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown.
 * &lt;p&gt;
 * By convention, classes that implement this interface should override
 * &lt;tt&gt;Object.clone&lt;/tt&gt; (which is protected) with a public method.
 * See {@link java.lang.Object#clone()} for details on overriding this
 * method.
 * &lt;p&gt;
 * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &lt;tt&gt;clone&lt;/tt&gt; method.
 * Therefore, it is not possible to clone an object merely by virtue of the
 * fact that it implements this interface.  Even if the clone method is invoked
 * reflectively, there is no guarantee that it will succeed.
 *
 * @author  unascribed
 * @see     java.lang.CloneNotSupportedException
 * @see     java.lang.Object#clone()
 * @since   JDK1.0
 */
public interface Cloneable {
}</code></pre>
<p><strong>Cloneable接口的作用仅仅是标记作用，实现了Cloneable接口的类，则意味着标记了该类的对象是可以做克隆操作的。Java对象要支持clone功能。但不是所有Java对象都应该可以clone，而是要让用户自己标记出哪些类是可以clone的，这是Cloneable接口的意义</strong>。</p>
<p><strong>为什么不把clone方法定义成Cloneable接口中的抽象方法，而是定义在java.lang.Object类中呢？</strong></p>
<p>clone()的语义有特殊性，最好是有JVM的直接支持，然后用户代码就算要自定义clone()最好也要调用JVM提供的基础实现然后再添加自己的功能（也就是大家经常简单的在clone()中先调用super.clone()的做法）。</p>
<p>JVM要直接支持，得在API里找地方来暴露出这个支持给Java代码调用才行啊。最直观的做法就是把clone()方法的基本实现放在一个所有可以clone的类都能访问到的基类中，让可clone的类继承这一实现。</p>
<p>但是我们不希望把clone()的基本实现放在一个特殊基类中，消耗掉Java类唯一的“基类”槽。那还能放哪里呢？干脆就放在java.lang.Object这个所有Java类的共通基类上吧。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2020/04/17/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>String和StringBuffer、StringBuilder</title>
    <url>/2020/04/21/String%E5%92%8CStringBuffer%E3%80%81StringBuilder/</url>
    <content><![CDATA[<h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a><strong>可变性</strong></h3><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<blockquote>
<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p>
</blockquote>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的</p>
<pre><code>AbstractStringBuilder.java</code></pre><pre><code class="java">abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /**
     * The value is used for character storage.
     */
    char[] value;

    /**
     * The count is the number of characters used.
     */
    int count;

    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }</code></pre>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性**"></a>线程安全性**</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h3><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<h3 id="对于三者使用的总结："><a href="#对于三者使用的总结：" class="headerlink" title="对于三者使用的总结："></a><strong>对于三者使用的总结：</strong></h3><ol>
<li>操作少量的数据: 适用 String</li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
</search>
