<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java创建对象的几种方式</title>
    <url>/2020/04/17/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Java创建对象的几种方式"><a href="#Java创建对象的几种方式" class="headerlink" title="Java创建对象的几种方式"></a>Java创建对象的几种方式</h1><h3 id="1-用new关键字常简对象"><a href="#1-用new关键字常简对象" class="headerlink" title="1.用new关键字常简对象"></a>1.用new关键字常简对象</h3><pre><code class="java">public class Main{
    public static void main(String[] args) {
        Main main = new Main();
        main.print();
    }

    public void print() {
        System.out.println(&quot;使用new关键字创建对象&quot;);
    }
}</code></pre>
<h3 id="2-使用反射机制创建对象"><a href="#2-使用反射机制创建对象" class="headerlink" title="2.使用反射机制创建对象"></a>2.使用反射机制创建对象</h3><p>用Class类或Constructor类的newInstance()方法。需要使用构造器。</p>
<blockquote>
<p>当使用Class类的newInstance()方法，调用的是无参构造方法。</p>
</blockquote>
<pre><code class="java">public class Main{
    public static void main(String[] args) throws IllegalAccessException, InstantiationException {
        Main main = Main.class.newInstance();
    }

    public void print() {
        System.out.println(&quot;使用new关键字创建对象&quot;);
    }
}</code></pre>
<blockquote>
<p>当使用java.lang.reflect.Constructor类里的newInstance方法，调用的是有参构造方法。</p>
</blockquote>
<pre><code class="java">public class Main{

    private int num;

    public Main(int num) {
        this.num = num;
    }

    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class p1 = Class.forName(&quot;Main&quot;);
        Constructor p2 = p1.getConstructor(String.class);
        Main main = (Main)p2.newInstance(1);
    }

    public void print() {
        System.out.println(&quot;使用new关键字创建对象&quot;);
    }
}</code></pre>
<h3 id="3、通过object类的clone方法"><a href="#3、通过object类的clone方法" class="headerlink" title="3、通过object类的clone方法"></a>3、通过object类的clone方法</h3><p>​    需要实现Cloneable接口，重写object类的clone方法。无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数</p>
<h3 id="4、使用反序列化"><a href="#4、使用反序列化" class="headerlink" title="4、使用反序列化"></a>4、使用反序列化</h3><p>​    通过ObjectInputStream的readObject()方法反序列化类当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。在反序列化时，JVM创建对象并不会调用任何构造函数。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
</search>
