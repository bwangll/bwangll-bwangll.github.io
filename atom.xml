<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bwang的博客</title>
  <icon>https://www.gravatar.com/avatar/f08443801db2ac448372f818fe94da1d</icon>
  <subtitle>面朝大海，春暖花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-06T05:21:37.690Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>bwang</name>
    <email>1415086046@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红黑树深入剖析及Java实现</title>
    <link href="http://yoursite.com/2020/04/06/%E8%AF%BE%E7%A8%8BMap/"/>
    <id>http://yoursite.com/2020/04/06/%E8%AF%BE%E7%A8%8BMap/</id>
    <published>2020-04-06T04:10:24.000Z</published>
    <updated>2020-04-06T05:21:37.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="/" class="lazyload" data-src="img%5CCollection%E4%B8%8EMap.bmp"  alt=""></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li><strong>HashMap&lt;K,V&gt;</strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><strong>LinkedHashMap&lt;K,V&gt;</strong>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法演示</p><pre><code class="java">public class MapDemo {    public static void main(String[] args) {        //创建 map对象        HashMap&lt;String, String&gt;  map = new HashMap&lt;String, String&gt;();        //添加元素到集合        map.put(&quot;黄晓明&quot;, &quot;杨颖&quot;);        map.put(&quot;文章&quot;, &quot;马伊琍&quot;);        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        System.out.println(map);        //String remove(String key)        System.out.println(map.remove(&quot;邓超&quot;));        System.out.println(map);        // 想要查看 黄晓明的媳妇 是谁        System.out.println(map.get(&quot;黄晓明&quot;));        System.out.println(map.get(&quot;邓超&quot;));        }}</code></pre><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h2 id="1-4-Map集合遍历键找值方式"><a href="#1-4-Map集合遍历键找值方式" class="headerlink" title="1.4   Map集合遍历键找值方式"></a>1.4   Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><pre><code class="java">public class MapDemo01 {    public static void main(String[] args) {        //创建Map集合对象         HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();        //添加元素到集合         map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);        //获取所有的键  获取键集        Set&lt;String&gt; keys = map.keySet();        // 遍历键集 得到 每一个键        for (String key : keys) {              //key  就是键            //获取对应值            String value = map.get(key);            System.out.println(key+&quot;的CP是：&quot;+value);        }      }}</code></pre><p>遍历图解：</p><p><img src="/" class="lazyload" data-src="img%5CMap%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp"  alt=""></p><h2 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5  Entry键值对对象"></a>1.5  Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><pre><code class="java">public class MapDemo02 {    public static void main(String[] args) {        // 创建Map集合对象         HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();        // 添加元素到集合         map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);        // 获取 所有的 entry对象  entrySet        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();        // 遍历得到每一个entry对象        for (Entry&lt;String, String&gt; entry : entrySet) {               // 解析             String key = entry.getKey();            String value = entry.getValue();              System.out.println(key+&quot;的CP是:&quot;+value);        }    }}</code></pre><p>遍历图解：</p><p><img src="/" class="lazyload" data-src="img%5CMap%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp"  alt=""></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><pre><code class="java">public class Student {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public boolean equals(Object o) {        if (this == o)            return true;        if (o == null || getClass() != o.getClass())            return false;        Student student = (Student) o;        return age == student.age &amp;&amp; Objects.equals(name, student.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age);    }}</code></pre><p>编写测试类：</p><pre><code class="java">public class HashMapTest {    public static void main(String[] args) {        //1,创建Hashmap集合对象。        Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;();        //2,添加元素。        map.put(newStudent(&quot;lisi&quot;,28), &quot;上海&quot;);        map.put(newStudent(&quot;wangwu&quot;,22), &quot;北京&quot;);        map.put(newStudent(&quot;zhaoliu&quot;,24), &quot;成都&quot;);        map.put(newStudent(&quot;zhouqi&quot;,25), &quot;广州&quot;);        map.put(newStudent(&quot;wangwu&quot;,22), &quot;南京&quot;);        //3,取出元素。键找值方式        Set&lt;Student&gt;keySet = map.keySet();        for(Student key: keySet){            Stringvalue = map.get(key);            System.out.println(key.toString()+&quot;.....&quot;+value);        }    }}</code></pre><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><pre><code class="java">public class LinkedHashMapDemo {    public static void main(String[] args) {        LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;();        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);        map.put(&quot;李晨&quot;, &quot;范冰冰&quot;);        map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;);        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        for (Entry&lt;String, String&gt; entry : entrySet) {            System.out.println(entry.getKey() + &quot;  &quot; + entry.getValue());        }    }}</code></pre><p>结果:</p><pre><code>邓超  孙俪李晨  范冰冰刘德华  朱丽倩</code></pre><h2 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h2><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li>获取一个字符串对象</li><li>创建一个Map集合，键代表字符，值代表次数。</li><li>遍历字符串得到每个字符。</li><li>判断Map中是否有该键。</li><li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li>打印最终结果</li></ol><p><strong>代码：</strong></p><pre><code class="java">public class MapTest {public static void main(String[] args) {        //友情提示        System.out.println(&quot;请录入一个字符串:&quot;);        String line = new Scanner(System.in).nextLine();        // 定义 每个字符出现次数的方法        findChar(line);    }    private static void findChar(String line) {        //1:创建一个集合 存储  字符 以及其出现的次数        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();        //2:遍历字符串        for (int i = 0; i &lt; line.length(); i++) {            char c = line.charAt(i);            //判断 该字符 是否在键集中            if (!map.containsKey(c)) {//说明这个字符没有出现过                //那就是第一次                map.put(c, 1);            } else {                //先获取之前的次数                Integer count = map.get(c);                //count++;                //再次存入  更新                map.put(c, ++count);            }        }        System.out.println(map);    }}</code></pre><h1 id="第二章-补充知识点"><a href="#第二章-补充知识点" class="headerlink" title="第二章 补充知识点"></a>第二章 补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><pre><code class="java">public class Demo01 {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;abc&quot;);        list.add(&quot;def&quot;);        list.add(&quot;ghi&quot;);        System.out.println(list);    }}</code></pre><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><pre><code class="java">public class HelloJDK9 {      public static void main(String[] args) {          Set&lt;String&gt; str1=Set.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);          //str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合          System.out.println(str1);          Map&lt;String,Integer&gt; str2=Map.of(&quot;a&quot;,1,&quot;b&quot;,2);          System.out.println(str2);          List&lt;String&gt; str3=List.of(&quot;a&quot;,&quot;b&quot;);          System.out.println(str3);      }  } </code></pre><p>需要注意以下两点：</p><blockquote><p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p><p>2:返回的集合是不可变的；</p></blockquote><h2 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p><ol><li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序     </p><p>   <img src="/" class="lazyload" data-src="img/debug1.png"  alt=""></p></li><li><p>点击Debug运行模式       <img src="/" class="lazyload" data-src="img%5Cdebug2.png"  alt="">                                                                                                                                                                      </p></li><li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p><p> <img src="/" class="lazyload" data-src="img%5Cdebug3.png"  alt="">)<img src="/" class="lazyload" data-src="img%5Cdebug4.png"  alt=""></p></li><li><p>Debug调试窗口介绍</p><p> <img src="/" class="lazyload" data-src="img%5Cdebug5.png"  alt=""></p></li><li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p><p><img src="/" class="lazyload" data-src="img%5Cdebug6.png"  alt=""></p></li><li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p><p><img src="/" class="lazyload" data-src="img%5Cdebug7.png"  alt=""></p></li><li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p><p><img src="/" class="lazyload" data-src="img%5Cdebug8.png"  alt=""></p><p>回车之后效果：<img src="/" class="lazyload" data-src="img%5Cdebug9.png"  alt=""></p><p>调试界面效果：<img src="/" class="lazyload" data-src="img%5Cdebug0.png"  alt=""></p></li><li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p><p><img src="/" class="lazyload" data-src="img%5Cdebug11.png"  alt=""></p></li><li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p><p><img src="/" class="lazyload" data-src="img%5Cdebug12.png"  alt=""></p></li><li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p><p><img src="/" class="lazyload" data-src="img%5Cdebug13.png"  alt=""></p></li><li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p><p><img src="/" class="lazyload" data-src="img%5Cdebug14.png"  alt=""></p></li><li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p><p><img src="/" class="lazyload" data-src="img%5Cdebug15.png"  alt=""></p></li><li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p><p><img src="/" class="lazyload" data-src="img%5Cdebug16.png"  alt=""></p></li><li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p><p><img src="/" class="lazyload" data-src="img%5Cdebug17.png"  alt=""></p></li></ol><h1 id="第三章-模拟斗地主洗牌发牌"><a href="#第三章-模拟斗地主洗牌发牌" class="headerlink" title="第三章  模拟斗地主洗牌发牌"></a>第三章  模拟斗地主洗牌发牌</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p><p><img src="/" class="lazyload" data-src="img%5C%E6%96%97%E5%9C%B0%E4%B8%BB.png"  alt=""></p><p>具体规则：</p><ol><li>组装54张扑克牌将</li><li>54张牌顺序打乱</li><li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li><li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li></ol><blockquote><p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p></blockquote><h2 id="3-2-案例需求分析"><a href="#3-2-案例需求分析" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol><li>准备牌：</li></ol><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p><ol start="2"><li>洗牌：</li></ol><p>通过数字完成洗牌发牌</p><ol start="3"><li>发牌：</li></ol><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p><ol start="4"><li>看牌：</li></ol><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p><p><img src="/" class="lazyload" data-src="img%5C%E6%96%97%E5%9C%B0%E4%B8%BB%E5%88%86%E6%9E%90.png"  alt=""></p><h2 id="3-3-实现代码步骤"><a href="#3-3-实现代码步骤" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><pre><code class="java">public class Poker {    public static void main(String[] args) {        /*         * 1组装54张扑克牌         */        // 1.1 创建Map集合存储        HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;();        // 1.2 创建 花色集合 与 数字集合        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();        // 1.3 存储 花色 与数字        Collections.addAll(colors, &quot;♦&quot;, &quot;♣&quot;, &quot;♥&quot;, &quot;♠&quot;);        Collections.addAll(numbers, &quot;2&quot;, &quot;A&quot;, &quot;K&quot;, &quot;Q&quot;, &quot;J&quot;, &quot;10&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;);        // 设置 存储编号变量        int count = 1;        pokerMap.put(count++, &quot;大王&quot;);        pokerMap.put(count++, &quot;小王&quot;);        // 1.4 创建牌 存储到map集合中        for (String number : numbers) {            for (String color : colors) {                String card = color + number;                pokerMap.put(count++, card);            }        }        /*         * 2 将54张牌顺序打乱         */        // 取出编号 集合        Set&lt;Integer&gt; numberSet = pokerMap.keySet();        // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中        ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;();        numberList.addAll(numberSet);        // 打乱顺序        Collections.shuffle(numberList);        // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌        // 3.1 发牌的编号        // 创建三个玩家编号集合 和一个 底牌编号集合        ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;();        ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;();        // 3.2发牌的编号        for (int i = 0; i &lt; numberList.size(); i++) {            // 获取该编号            Integer no = numberList.get(i);            // 发牌            // 留出底牌            if (i &gt;= 51) {                dipaiNo.add(no);            } else {                if (i % 3 == 0) {                    noP1.add(no);                } else if (i % 3 == 1) {                    noP2.add(no);                } else {                    noP3.add(no);                }            }        }        // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌        // 4.1 对手中编号进行排序        Collections.sort(noP1);        Collections.sort(noP2);        Collections.sort(noP3);        Collections.sort(dipaiNo);        // 4.2 进行牌面的转换        // 创建三个玩家牌面集合 以及底牌牌面集合        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();        // 4.3转换        for (Integer i : noP1) {            // 4.4 根据编号找到 牌面 pokerMap            String card = pokerMap.get(i);            // 添加到对应的 牌面集合中            player1.add(card);        }        for (Integer i : noP2) {            String card = pokerMap.get(i);            player2.add(card);        }        for (Integer i : noP3) {            String card = pokerMap.get(i);            player3.add(card);        }        for (Integer i : dipaiNo) {            String card = pokerMap.get(i);            dipai.add(card);        }        //4.5 查看        System.out.println(&quot;令狐冲：&quot;+player1);        System.out.println(&quot;石破天：&quot;+player2);        System.out.println(&quot;鸠摩智：&quot;+player3);        System.out.println(&quot;底牌：&quot;+dipai);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map集合&quot;&gt;&lt;a href=&quot;#Map集合&quot; class=&quot;headerlink&quot; title=&quot;Map集合&quot;&gt;&lt;/a&gt;Map集合&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/categories/JavaSE/"/>
    
    
      <category term="Map" scheme="http://yoursite.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>红黑树深入剖析及Java实现</title>
    <link href="http://yoursite.com/2020/04/06/demo/"/>
    <id>http://yoursite.com/2020/04/06/demo/</id>
    <published>2020-04-06T02:09:36.000Z</published>
    <updated>2020-04-06T03:24:38.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红黑树深入剖析及Java实现"><a href="#红黑树深入剖析及Java实现" class="headerlink" title="红黑树深入剖析及Java实现"></a>红黑树深入剖析及Java实现</h1><p>红黑树是二叉平衡树的一种。</p><h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><p>二叉查找树（Binary Search Tree，简称BST）是一颗二叉树，它的左节点的值要比父节点的值小，右节点的值要比父节点的值大。他的高度决定了它的查找效率。</p><p>在理想的情况下，二叉查找树增删改查的时间复杂度为O(logN）（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的</p><p><img src="/" class="lazyload" data-src="E:%5CYNote%5Cimage%5Cimage-20200405215130829.png"  alt="image-20200405215130829"></p><h3 id="BST的查找操作"><a href="#BST的查找操作" class="headerlink" title="BST的查找操作"></a>BST的查找操作</h3><pre><code class="java">T key = a search keyNode root = point to the root of a BSTwhile(true) {    if(root == null) {        break;    }    if(key.compareTo(root.value) &lt; 0) {        root = root.left;    } else {        root = root.right;    }}return null;</code></pre><p>从程序中可以看出，当BST查找的时候，先与当前节点进行比较：</p><ul><li>如果相等的话就返回当前节点；</li><li>如果少于当前节点则继续查找当前节点的左节点；</li><li>如果大于当前节点则继续查找当前节点的右节点。</li></ul><p>直到当前节点指针为空或者查找到对应的节点，程序查找结束。</p><h3 id="BST的插入操作"><a href="#BST的插入操作" class="headerlink" title="BST的插入操作"></a>BST的插入操作</h3><pre><code class="java">Node node = create a new node with specify valueNode root = point the root node of a BSTNode parent = null;//find the parent node to append the new nodewhile(true){   if(root==null)break;   parent = root;   if(node.value.compareTo(root.value)&lt;=0){      root = root.left;     }else{      root = root.right;   } }if(parent!=null){   if(node.value.compareTo(parent.value)&lt;=0){//append to left      parent.left = node;   }else{//append to right      parent.right = node;   }}</code></pre><p>插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上。</p><h3 id="BST的删除操作"><a href="#BST的删除操作" class="headerlink" title="BST的删除操作"></a>BST的删除操作</h3><p>删除操作的步骤如下：</p><ol><li>查找到要删除的节点。</li><li>如果待删除的节点是叶子节点，则直接删除。</li><li>如果待删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。(也就是被删除节点的右儿子)</li></ol><p><img src="/" class="lazyload" data-src="E:%5CYNote%5Cimage%5Cimage-20200405220850523.png"  alt="image-20200405220850523"></p><h3 id="BST存在的问题"><a href="#BST存在的问题" class="headerlink" title="BST存在的问题"></a>BST存在的问题</h3><p>BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。</p><h2 id="RBTree"><a href="#RBTree" class="headerlink" title="RBTree"></a>RBTree</h2><p>基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。</p><p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。</p><p>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p><h3 id="RBTree（红黑树）的定义"><a href="#RBTree（红黑树）的定义" class="headerlink" title="RBTree（红黑树）的定义"></a>RBTree（红黑树）的定义</h3><p>RBTree的定义如下:</p><ol><li>任何一个节点都有颜色，黑色或者红色</li><li>根节点是黑色的</li><li>父子节点之间不能出现两个连续的红节点</li><li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等</li><li>空节点被认为是黑色的</li></ol><p>数据结构表示如下：</p><pre><code class="Java">class  Node&lt;T&gt;{   public  T value;   public   Node&lt;T&gt; parent;   public   boolean isRed;   public   Node&lt;T&gt; left;   public   Node&lt;T&gt; right;}</code></pre><p>RBTree在理论上还是一棵BST树，但是它在对BST的插入和删除操作时会维持树的平衡，即保证树的高度在[logN,logN+1]（理论上，极端的情况下可以出现RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)。RBTree的查找操作就是BST的查找操作。</p><h3 id="RBTree的旋转操作"><a href="#RBTree的旋转操作" class="headerlink" title="RBTree的旋转操作"></a>RBTree的旋转操作</h3><p>旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到平衡。<br>Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。</p><p><img src="/" class="lazyload" data-src="E:%5CYNote%5Cimage%5Cimage-20200405221336991.png"  alt="image-20200405221336991"></p><h3 id="RBTree的查找操作"><a href="#RBTree的查找操作" class="headerlink" title="RBTree的查找操作"></a>RBTree的查找操作</h3><p>RBTree的查找操作和BST的查找操作是一样的。请参考BST的查找操作代码。</p><h3 id="RBTree的插入操作"><a href="#RBTree的插入操作" class="headerlink" title="RBTree的插入操作"></a>RBTree的插入操作</h3><p>RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称插入修复），使得它符合RBTree的定义。</p><p>新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。</p><p>插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：</p><ol><li><p>叔叔节点也为红色。</p></li><li><p>叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。</p></li><li><p>叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。</p><h4 id="插入操作-case-1"><a href="#插入操作-case-1" class="headerlink" title="插入操作-case 1"></a>插入操作-case 1</h4><p>case 1的操作是将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTRee的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。</p><p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/80/v2-85d7be8e54ae9f904d86bf5f5ee3b4bc_720w.png"  alt="img"></p><h4 id="插入操作-case-2"><a href="#插入操作-case-2" class="headerlink" title="插入操作-case 2"></a>插入操作-case 2</h4><p>case 2的操作是将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTRee的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。</p><p><img src="/" class="lazyload" data-src="https://pic3.zhimg.com/80/v2-cd2171937e0ed68bca55214357e6669e_720w.png"  alt="img"></p><h4 id="插入操作-case-3"><a href="#插入操作-case-3" class="headerlink" title="插入操作-case 3"></a>插入操作-case 3</h4><p>case 3的操作是将C节点进行左旋，这样就从case 3转换成case 2了，然后针对case 2进行操作处理就行了。case 2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。</p><p><img src="/" class="lazyload" data-src="https://pic4.zhimg.com/80/v2-8594087429e54acbbc2aa6ae9da8cc5f_720w.png"  alt="img"></p><h4 id="插入操作的总结"><a href="#插入操作的总结" class="headerlink" title="插入操作的总结"></a>插入操作的总结</h4><p>插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case 1操作会将父节点，叔叔节点和祖父节点进行换颜色，有可能会导致祖父节点不平衡(红黑树定义3)。这个时候需要对祖父节点为起点进行调节（向上回溯）。</p><p>祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的追溯的过程中，针对插入的3中情况进行调节。直到符合红黑树的定义为止。直到牵涉的节点都符合了红黑树的定义，修复操作结束。</p><p>如果上面的3中情况如果对应的操作是在右子树上，做对应的镜像操作就是了。</p><h3 id="RBTree的删除操作"><a href="#RBTree的删除操作" class="headerlink" title="RBTree的删除操作"></a>RBTree的删除操作</h3><p>删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的。</p><p>删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。</p><p>删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。</p><p>删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p><p>删除修复操作分为四种情况(删除黑节点后)：</p><ol><li>待删除的节点的兄弟节点是红色的节点。</li><li>待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。</li><li>待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。</li><li>待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。</li></ol><h4 id="删除操作-case-1"><a href="#删除操作-case-1" class="headerlink" title="删除操作-case 1"></a>删除操作-case 1</h4><p>由于兄弟节点是红色节点的时候，无法借调黑节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。</p><p>case 1这样转换之后就会变成后面的case 2，case 3，或者case 4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。</p><p>之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。</p><p><img src="/" class="lazyload" data-src="https://pic4.zhimg.com/80/v2-46e732e84148b9bca53e995689e9ba9f_720w.png"  alt="img"></p><h4 id="删除操作-case-2"><a href="#删除操作-case-2" class="headerlink" title="删除操作-case 2"></a>删除操作-case 2</h4><p>case 2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。</p><p>case 2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。</p><p><img src="/" class="lazyload" data-src="https://pic2.zhimg.com/80/v2-7975d1b235cd30c0bafb716b585ba45d_720w.png"  alt="img"></p><h4 id="删除操作-case-3"><a href="#删除操作-case-3" class="headerlink" title="删除操作-case 3"></a>删除操作-case 3</h4><p>case 3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case 4状态了，在case 4状态下可以将D，E节点都阶段过来，通过将两个节点变成黑色来保证红黑树的整体平衡。</p><p>之所以说case-3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，他是通过case 2操作完后向上回溯出现的状态。之所以会出现case 3和后面的case 4的情况，是因为可以通过借用侄子节点的红色，变成黑色来符合红黑树定义4.</p><p><img src="/" class="lazyload" data-src="https://pic3.zhimg.com/80/v2-04dbb22d25de3849d902582809198596_720w.png"  alt="img"></p><h4 id="删除操作-case-4"><a href="#删除操作-case-4" class="headerlink" title="删除操作-case 4"></a>删除操作-case 4</h4><p>Case 4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合RBTree的定义的。</p><p>Case 4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义。</p><p><img src="/" class="lazyload" data-src="https://pic4.zhimg.com/80/v2-a559407bb4847a140642d16c6301d7db_720w.png"  alt="img"></p><h4 id="删除操作的总结"><a href="#删除操作的总结" class="headerlink" title="删除操作的总结"></a>删除操作的总结</h4><p>红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。</p><p>对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。</p><p>对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。</p><p>红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。</p><h3 id="RBTree的Java实现"><a href="#RBTree的Java实现" class="headerlink" title="RBTree的Java实现"></a>RBTree的Java实现</h3><pre><code class="java">public class RBTreeNode&lt;T extends Comparable&lt;T&gt;&gt; {    private T value;//node value    private RBTreeNode&lt;T&gt; left;//left child pointer    private RBTreeNode&lt;T&gt; right;//right child pointer    private RBTreeNode&lt;T&gt; parent;//parent pointer    private boolean red;//color is red or not red    public RBTreeNode(){}    public RBTreeNode(T value){this.value=value;}    public RBTreeNode(T value,boolean isRed){this.value=value;this.red = isRed;}    public T getValue() {        return value;    }    void setValue(T value) {        this.value = value;    }    RBTreeNode&lt;T&gt; getLeft() {        return left;    }    void setLeft(RBTreeNode&lt;T&gt; left) {        this.left = left;    }    RBTreeNode&lt;T&gt; getRight() {        return right;    }    void setRight(RBTreeNode&lt;T&gt; right) {        this.right = right;    }    RBTreeNode&lt;T&gt; getParent() {        return parent;    }    void setParent(RBTreeNode&lt;T&gt; parent) {        this.parent = parent;    }    boolean isRed() {        return red;    }    boolean isBlack(){        return !red;    }    /**    * is leaf node    **/    boolean isLeaf(){        return left==null &amp;&amp; right==null;    }    void setRed(boolean red) {        this.red = red;    }    void makeRed(){        red=true;    }    void makeBlack(){        red=false;    }    @Override    public String toString(){        return value.toString();    }}</code></pre></li></ol><p>   public class RBTree&lt;T extends Comparable<T>&gt; {<br>       private final RBTreeNode<T> root;<br>       //node number<br>       private java.util.concurrent.atomic.AtomicLong size =<br>                       new java.util.concurrent.atomic.AtomicLong(0);</p><pre><code>   //in overwrite mode,all node&#39;s value can not  has same    value   //in non-overwrite mode,node can have same value, suggest don&#39;t use non-overwrite mode.   private volatile boolean overrideMode=true;   public RBTree(){       this.root = new RBTreeNode&lt;T&gt;();   }   public RBTree(boolean overrideMode){       this();       this.overrideMode=overrideMode;   }   public boolean isOverrideMode() {       return overrideMode;   }   public void setOverrideMode(boolean overrideMode) {       this.overrideMode = overrideMode;   }   /**    * number of tree number    * @return    */   public long getSize() {       return size.get();   }   /**    * get the root node    * @return    */   private RBTreeNode&lt;T&gt; getRoot(){       return root.getLeft();   }   /**    * add value to a new node,if this value exist in this tree,    * if value exist,it will return the exist value.otherwise return null    * if override mode is true,if value exist in the tree,    * it will override the old value in the tree    *     * @param value    * @return    */   public T addNode(T value){       RBTreeNode&lt;T&gt; t = new RBTreeNode&lt;T&gt;(value);       return addNode(t);   }   /**    * find the value by give value(include key,key used for search,    * other field is not used,@see compare method).if this value not exist return null    * @param value    * @return    */   public T find(T value){       RBTreeNode&lt;T&gt; dataRoot = getRoot();       while(dataRoot!=null){           int cmp = dataRoot.getValue().compareTo(value);           if(cmp&lt;0){               dataRoot = dataRoot.getRight();           }else if(cmp&gt;0){               dataRoot = dataRoot.getLeft();           }else{               return dataRoot.getValue();           }       }       return null;   }   /**    * remove the node by give value,if this value not exists in tree return null    * @param value include search key    * @return the value contain in the removed node    */   public T remove(T value){       RBTreeNode&lt;T&gt; dataRoot = getRoot();       RBTreeNode&lt;T&gt; parent = root;       while(dataRoot!=null){           int cmp = dataRoot.getValue().compareTo(value);           if(cmp&lt;0){               parent = dataRoot;               dataRoot = dataRoot.getRight();           }else if(cmp&gt;0){               parent = dataRoot;               dataRoot = dataRoot.getLeft();           }else{               if(dataRoot.getRight()!=null){                   RBTreeNode&lt;T&gt; min = removeMin(dataRoot.getRight());                   //x used for fix color balance                   RBTreeNode&lt;T&gt; x = min.getRight()==null ? min.getParent() : min.getRight();                   boolean isParent = min.getRight()==null;                   min.setLeft(dataRoot.getLeft());                   setParent(dataRoot.getLeft(),min);                   if(parent.getLeft()==dataRoot){                       parent.setLeft(min);                   }else{                       parent.setRight(min);                   }                   setParent(min,parent);                   boolean curMinIsBlack = min.isBlack();                   //inherit dataRoot&#39;s color                   min.setRed(dataRoot.isRed());                   if(min!=dataRoot.getRight()){                       min.setRight(dataRoot.getRight());                       setParent(dataRoot.getRight(),min);                   }                   //remove a black node,need fix color                   if(curMinIsBlack){                       if(min!=dataRoot.getRight()){                           fixRemove(x,isParent);                       }else if(min.getRight()!=null){                           fixRemove(min.getRight(),false);                       }else{                           fixRemove(min,true);                       }                   }               }else{                   setParent(dataRoot.getLeft(),parent);                   if(parent.getLeft()==dataRoot){                       parent.setLeft(dataRoot.getLeft());                   }else{                       parent.setRight(dataRoot.getLeft());                   }                   //current node is black and tree is not empty                   if(dataRoot.isBlack() &amp;&amp; !(root.getLeft()==null)){                       RBTreeNode&lt;T&gt; x = dataRoot.getLeft()==null                                            ? parent :dataRoot.getLeft();                       boolean isParent = dataRoot.getLeft()==null;                       fixRemove(x,isParent);                   }               }               setParent(dataRoot,null);               dataRoot.setLeft(null);               dataRoot.setRight(null);               if(getRoot()!=null){                   getRoot().setRed(false);                   getRoot().setParent(null);               }               size.decrementAndGet();               return dataRoot.getValue();           }       }       return null;   }   /**    * fix remove action    * @param node    * @param isParent    */   private void fixRemove(RBTreeNode&lt;T&gt; node,boolean isParent){       RBTreeNode&lt;T&gt; cur = isParent ? null : node;       boolean isRed = isParent ? false : node.isRed();       RBTreeNode&lt;T&gt; parent = isParent ? node : node.getParent();       while(!isRed &amp;&amp; !isRoot(cur)){           RBTreeNode&lt;T&gt; sibling = getSibling(cur,parent);           //sibling is not null,due to before remove tree color is balance           //if cur is a left node           boolean isLeft = parent.getRight()==sibling;           if(sibling.isRed() &amp;&amp; !isLeft){//case 1               //cur in right               parent.makeRed();               sibling.makeBlack();               rotateRight(parent);           }else if(sibling.isRed() &amp;&amp; isLeft){               //cur in left               parent.makeRed();               sibling.makeBlack();               rotateLeft(parent);           }else if(isBlack(sibling.getLeft()) &amp;&amp; isBlack(sibling.getRight())){//case 2               sibling.makeRed();               cur = parent;               isRed = cur.isRed();               parent=parent.getParent();           }else if(isLeft &amp;&amp; !isBlack(sibling.getLeft())                                    &amp;&amp; isBlack(sibling.getRight())){//case 3               sibling.makeRed();               sibling.getLeft().makeBlack();               rotateRight(sibling);           }else if(!isLeft &amp;&amp; !isBlack(sibling.getRight())                                            &amp;&amp; isBlack(sibling.getLeft()) ){               sibling.makeRed();               sibling.getRight().makeBlack();               rotateLeft(sibling);           }else if(isLeft &amp;&amp; !isBlack(sibling.getRight())){//case 4               sibling.setRed(parent.isRed());               parent.makeBlack();               sibling.getRight().makeBlack();               rotateLeft(parent);               cur=getRoot();           }else if(!isLeft &amp;&amp; !isBlack(sibling.getLeft())){               sibling.setRed(parent.isRed());               parent.makeBlack();               sibling.getLeft().makeBlack();               rotateRight(parent);               cur=getRoot();           }       }       if(isRed){           cur.makeBlack();       }       if(getRoot()!=null){           getRoot().setRed(false);           getRoot().setParent(null);       }   }   //get sibling node   private RBTreeNode&lt;T&gt; getSibling(RBTreeNode&lt;T&gt; node,RBTreeNode&lt;T&gt; parent){       parent = node==null ? parent : node.getParent();       if(node==null){           return parent.getLeft()==null ? parent.getRight() : parent.getLeft();       }       if(node==parent.getLeft()){           return parent.getRight();       }else{           return parent.getLeft();       }   }   private boolean isBlack(RBTreeNode&lt;T&gt; node){       return node==null || node.isBlack();   }   private boolean isRoot(RBTreeNode&lt;T&gt; node){       return root.getLeft() == node &amp;&amp; node.getParent()==null;   }   /**    * find the successor node    * @param node current node&#39;s right node    * @return    */   private RBTreeNode&lt;T&gt; removeMin(RBTreeNode&lt;T&gt; node){       //find the min node       RBTreeNode&lt;T&gt; parent = node;       while(node!=null &amp;&amp; node.getLeft()!=null){           parent = node;           node = node.getLeft();       }       //remove min node       if(parent==node){           return node;       }       parent.setLeft(node.getRight());       setParent(node.getRight(),parent);       //don&#39;t remove right pointer,it is used for fixed color balance       //node.setRight(null);       return node;   }   private T addNode(RBTreeNode&lt;T&gt; node){       node.setLeft(null);       node.setRight(null);       node.setRed(true);       setParent(node,null);       if(root.getLeft()==null){           root.setLeft(node);           //root node is black           node.setRed(false);           size.incrementAndGet();       }else{           RBTreeNode&lt;T&gt; x = findParentNode(node);           int cmp = x.getValue().compareTo(node.getValue());           if(this.overrideMode &amp;&amp; cmp==0){               T v = x.getValue();               x.setValue(node.getValue());               return v;           }else if(cmp==0){               //value exists,ignore this node               return x.getValue();           }           setParent(node,x);           if(cmp&gt;0){               x.setLeft(node);           }else{               x.setRight(node);           }           fixInsert(node);           size.incrementAndGet();       }       return null;   }   /**    * find the parent node to hold node x,if parent value equals x.value return parent.    * @param x    * @return    */   private RBTreeNode&lt;T&gt; findParentNode(RBTreeNode&lt;T&gt; x){       RBTreeNode&lt;T&gt; dataRoot = getRoot();       RBTreeNode&lt;T&gt; child = dataRoot;       while(child!=null){           int cmp = child.getValue().compareTo(x.getValue());           if(cmp==0){               return child;           }           if(cmp&gt;0){               dataRoot = child;               child = child.getLeft();           }else if(cmp&lt;0){               dataRoot = child;               child = child.getRight();           }       }       return dataRoot;   }   /**    * red black tree insert fix.    * @param x    */   private void fixInsert(RBTreeNode&lt;T&gt; x){       RBTreeNode&lt;T&gt; parent = x.getParent();       while(parent!=null &amp;&amp; parent.isRed()){           RBTreeNode&lt;T&gt; uncle = getUncle(x);           if(uncle==null){//need to rotate               RBTreeNode&lt;T&gt; ancestor = parent.getParent();               //ancestor is not null due to before before add,tree color is balance               if(parent == ancestor.getLeft()){                   boolean isRight = x == parent.getRight();                   if(isRight){                       rotateLeft(parent);                   }                   rotateRight(ancestor);                   if(isRight){                       x.setRed(false);                       parent=null;//end loop                   }else{                       parent.setRed(false);                   }                   ancestor.setRed(true);               }else{                   boolean isLeft = x == parent.getLeft();                   if(isLeft){                       rotateRight(parent);                   }                   rotateLeft(ancestor);                   if(isLeft){                       x.setRed(false);                       parent=null;//end loop                   }else{                       parent.setRed(false);                   }                   ancestor.setRed(true);               }           }else{//uncle is red               parent.setRed(false);               uncle.setRed(false);               parent.getParent().setRed(true);               x=parent.getParent();               parent = x.getParent();           }       }       getRoot().makeBlack();       getRoot().setParent(null);   }   /**    * get uncle node    * @param node    * @return    */   private RBTreeNode&lt;T&gt; getUncle(RBTreeNode&lt;T&gt; node){       RBTreeNode&lt;T&gt; parent = node.getParent();       RBTreeNode&lt;T&gt; ancestor = parent.getParent();       if(ancestor==null){           return null;       }       if(parent == ancestor.getLeft()){           return ancestor.getRight();       }else{           return ancestor.getLeft();       }   }   private void rotateLeft(RBTreeNode&lt;T&gt; node){       RBTreeNode&lt;T&gt; right = node.getRight();       if(right==null){           throw new java.lang.IllegalStateException(&quot;right node is null&quot;);       }       RBTreeNode&lt;T&gt; parent = node.getParent();       node.setRight(right.getLeft());       setParent(right.getLeft(),node);       right.setLeft(node);       setParent(node,right);       if(parent==null){//node pointer to root           //right  raise to root node           root.setLeft(right);           setParent(right,null);       }else{           if(parent.getLeft()==node){               parent.setLeft(right);           }else{               parent.setRight(right);           }           //right.setParent(parent);           setParent(right,parent);       }   }   private void rotateRight(RBTreeNode&lt;T&gt; node){       RBTreeNode&lt;T&gt; left = node.getLeft();       if(left==null){           throw new java.lang.IllegalStateException(&quot;left node is null&quot;);       }       RBTreeNode&lt;T&gt; parent = node.getParent();       node.setLeft(left.getRight());       setParent(left.getRight(),node);       left.setRight(node);       setParent(node,left);       if(parent==null){           root.setLeft(left);           setParent(left,null);       }else{           if(parent.getLeft()==node){               parent.setLeft(left);           }else{               parent.setRight(left);           }           setParent(left,parent);       }   }   private void setParent(RBTreeNode&lt;T&gt; node,RBTreeNode&lt;T&gt; parent){       if(node!=null){           node.setParent(parent);           if(parent==root){               node.setParent(null);           }       }   }   /**    * debug method,it used print the given node and its children nodes,    * every layer output in one line    * @param root    */   public void printTree(RBTreeNode&lt;T&gt; root){       java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; queue =new java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt;();       java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; queue2 =new java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt;();       if(root==null){           return ;       }       queue.add(root);       boolean firstQueue = true;       while(!queue.isEmpty() || !queue2.isEmpty()){           java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; q = firstQueue ? queue : queue2;           RBTreeNode&lt;T&gt; n = q.poll();           if(n!=null){               String pos = n.getParent()==null ? &quot;&quot; : ( n == n.getParent().getLeft()                                                                        ? &quot; LE&quot; : &quot; RI&quot;);               String pstr = n.getParent()==null ? &quot;&quot; : n.getParent().toString();               String cstr = n.isRed()?&quot;R&quot;:&quot;B&quot;;               cstr = n.getParent()==null ? cstr : cstr+&quot; &quot;;               System.out.print(n+&quot;(&quot;+(cstr)+pstr+(pos)+&quot;)&quot;+&quot;\t&quot;);               if(n.getLeft()!=null){                   (firstQueue ? queue2 : queue).add(n.getLeft());               }               if(n.getRight()!=null){                   (firstQueue ? queue2 : queue).add(n.getRight());               }           }else{               System.out.println();               firstQueue = !firstQueue;           }       }   }   public static void main(String[] args) {       RBTree&lt;String&gt; bst = new RBTree&lt;String&gt;();       bst.addNode(&quot;d&quot;);       bst.addNode(&quot;d&quot;);       bst.addNode(&quot;c&quot;);       bst.addNode(&quot;c&quot;);       bst.addNode(&quot;b&quot;);       bst.addNode(&quot;f&quot;);       bst.addNode(&quot;a&quot;);       bst.addNode(&quot;e&quot;);       bst.addNode(&quot;g&quot;);       bst.addNode(&quot;h&quot;);       bst.remove(&quot;c&quot;);       bst.printTree(bst.getRoot());   }</code></pre><p>   }</p><p>   ```</p><p>   代码调试的时候，printTree输出格式如下:<br>   d(B)<br>   b(B d LE) g(R d RI)<br>   a(R b LE) e(B g LE) h(B g RI)<br>   f(R e RI)</p><p>   括号左边表示元素的内容。括号内的第一个元素表示颜色，B表示black，R表示red；第二个元素表示父元素的值；第三个元素表示左右，LE表示在父元素的左边。RI表示在父元素的右边。</p><p>   第一个元素d是root节点，由于它没有父节点，所以括号内只有一个元素。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度平衡。作为平衡二叉查找树，旋转是一个必不可少的操作。通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。</p><p>   红黑树里面的插入和删除的操作比较难理解，这时要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的。在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入具体的分为3种情况，删除分为4种情况。</p><p>   整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红黑树深入剖析及Java实现&quot;&gt;&lt;a href=&quot;#红黑树深入剖析及Java实现&quot; class=&quot;headerlink&quot; title=&quot;红黑树深入剖析及Java实现&quot;&gt;&lt;/a&gt;红黑树深入剖析及Java实现&lt;/h1&gt;&lt;p&gt;红黑树是二叉平衡树的一种。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
